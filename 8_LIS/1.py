# this code is generated by chatgpt with given pseudocode

def find_lis(a):
    n = len(a)
    b = [0] * n  # Array to store the length of LIS ending at each position
    s = [0] * (n + 1)  # Array to store the smallest ending element of LIS of length i
    size_ = 1  # Initial LIS length
    s[1] = a[0]  # Initialize with the first element
    b[0] = 1  # Length of LIS ending at the first element is 1

    for i in range(1, n):
        # Binary search for the position in `s`
        pos = 0
        l, r = 1, size_
        while l <= r:
            mid = (l + r) // 2
            if a[i] > s[mid]:
                pos = mid
                l = mid + 1
            else:
                r = mid - 1
        s[pos + 1] = a[i]  # Update the LIS ending element for position `pos + 1`
        b[i] = pos + 1  # Update LIS length ending at position `i`
        if pos + 1 > size_:
            size_ = pos + 1  # Update the LIS size if needed
        print("after cope with ", a[i], ", s is :" , s[1:size_+1])
    print("b is ",b)
    # Backtrack to reconstruct the LIS
    m = size_
    j = n - 1
    LST = [0] * size_  # Array to store the LIS elements
    while m > 0:
        while b[j] != m:
            j -= 1
        LST[m - 1] = a[j]
        m -= 1

    return LST


# Example usage
a = [2, 1, 4, 3, 2, 5, 6, 3, 2] 
lis = find_lis(a)
# expected to print [1, 2, 5, 6], an array of size 4
print("Longest Increasing Subsequence:", lis)
